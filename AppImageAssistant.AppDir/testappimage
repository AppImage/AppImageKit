#!/bin/bash

#
# Test an AppDir or AppImage on a given ISO or squashfs base system
# TODO: Check https://github.com/FGrose/livecd-tools/blob/liveimage-mount/tools/liveimage-mount
#

set -e
# set -x

HERE=$(dirname $(readlink -f "${0}"))
export PATH=$HERE:$HERE/usr/bin:$PATH

if [ "$1" == "-i" ] ; then
    echo "Interactive mode ON."
    mode_i="true"
    set +e
    shift
fi

if [ "$1x" == "x" ] ; then
    echo "Please specify a ISO or squashfs base system to run the AppImage on"
    exit 1
fi

if [ "$2x" == "x" ] ; then
    echo "Please specify an AppDir or AppImage outside the ISO or command inside the ISO to be run"
    exit 1
fi

export PREF=$RANDOM

mkdir -p /tmp/$PREF/unionfs/ro
mkdir -p /tmp/$PREF/unionfs/root
mkdir -p /tmp/$PREF/unionfs/rw
mkdir -p /tmp/$PREF/union
mkdir -p /tmp/$PREF/iso

# If ISO was specified, then mount it and find contained filesystem
THEFS="$1"
if [ ${1: -4} == ".iso" ] ; then
    ISO="$1"
    mount -o loop,ro "$ISO" /tmp/$PREF/iso
    # If there is a squashfs file named $ISO.buildsquash then we overlay-
    # mount this as well. This can significantly speed up subsequent builds
    # because dependencies can be installed there. The squashfs file can be
    # generated by squashing the unionfs/rw directory.
    if [ -e $ISO.buildsquash ] ; then
        mount -o loop,ro "$ISO.buildsquash" /tmp/$PREF/unionfs/ro
    fi
fi

# If sfs was provided, then assume it contains a rootfs use just that
THEFS="$1"
if [ ${1: -4} == ".sfs" ] ; then
    ISO="$1"
    mount -o loop,ro "$ISO" /tmp/$PREF/unionfs/root
fi

echo ""
echo "===================================================="
echo ""
echo $ISO

# In case of Ubuntu-like ISOs
if [ -e /tmp/$PREF/iso/casper/filesystem.squashfs ] ; then
  THEFS=/tmp/$PREF/iso/casper/filesystem.squashfs
  mount "$THEFS" /tmp/$PREF/unionfs/root -o loop,ro || exit 1
fi

# In case of Fedora-like ISOs
if [ -e /tmp/$PREF/iso/LiveOS/squashfs.img ] ; then
    mount -o loop,ro /tmp/$PREF/iso/LiveOS/squashfs.img /tmp/$PREF/iso/
    THEFS=/tmp/$PREF/iso/LiveOS/ext3fs.img || exit 1
    mount "$THEFS" /tmp/$PREF/unionfs/root -o loop,ro || exit 1
fi

# In case of debian-like ISOs
if [ -e /tmp/$PREF/iso/live/filesystem.squashfs ] ; then
  THEFS=/tmp/$PREF/iso/live/filesystem.squashfs
  mount "$THEFS" /tmp/$PREF/unionfs/root -o loop,ro || exit 1
fi

# In case of openSUSE-like ISOs
if [ -e /tmp/$PREF/iso/*-read-only.* ] ; then
  THEFS=$(ls /tmp/$PREF/iso/*-read-only.* | head -n 1)
  mount "$THEFS" /tmp/$PREF/unionfs/root -o loop,ro || exit 1
fi

trap atexit EXIT

atexit()
{    set +e
    umount -l /tmp/$PREF/union/var/lib/dbus 2>/dev/null
    umount -l /tmp/$PREF/union/etc/resolv.conf 2>/dev/null
    umount -l /tmp/$PREF/union/proc 2>/dev/null
    umount -l /tmp/$PREF/union/dev 2>/dev/null
    umount -l /tmp/$PREF/union/mnt 2>/dev/null
    umount -l /tmp/$PREF/union 2>/dev/null
    umount -l /tmp/$PREF/unionfs/ro 2>/dev/null
    umount -l /tmp/$PREF/unionfs/root 2>/dev/null
    umount -l /tmp/$PREF/iso 2>/dev/null
    umount -l /tmp/$PREF/iso 2>/dev/null
    umount -l /tmp/$PREF/iso 2>/dev/null
    rm -r /tmp/$PREF/unionfs/root
    rm -r /tmp/$PREF/unionfs/rw
    rm -r /tmp/$PREF/unionfs/ro
    rm -r /tmp/$PREF/unionfs
    rm -r /tmp/$PREF/union
    rm -r /tmp/$PREF/iso
    rm -r /tmp/$PREF/
}

unionfs-fuse -o allow_other,use_ino,suid,dev,nonempty -ocow,chroot=/tmp/$PREF/unionfs/,max_files=32768 /rw=RW:/ro=RO:/root=RO /tmp/$PREF/union

ls /tmp/$PREF/union/mnt >/dev/null && MNT=/mnt
# ls /tmp/$PREF/union/automake >/dev/null && MNT=/automake || echo "" # Puppy

if [ "x$MNT" == "x" ] ; then
    echo "Could not find free mountpoint"
    exit 1
fi

mount -t proc proc /tmp/$PREF/union/proc
mkdir -p /tmp/$PREF/union/var/lib/dbus
mount --bind /dev /tmp/$PREF/union/dev
mount --bind /var/lib/dbus /tmp/$PREF/union/var/lib/dbus
touch /tmp/$PREF/union/etc/resolv.conf || echo ""
mount --bind /etc/resolv.conf /tmp/$PREF/union/etc/resolv.conf
xhost local: >/dev/null 2>&1 # otherwise "cannot open display: :0.0"

# Store the AppImage/AppDir/command that was passed in and any arguments
cmd=$2
shift 2
args=$@

while [ true ]; do
  echo "Command to run: $cmd ${args[@]}"
  if [ "$mode_i" == true ]; then
    read -p "Press ENTER to run it, or type new command: " -a array
    if [ ${#array[@]} != 0 ]; then
      cmd="${array[0]}"
      args=("${array[@]:1}") # shift array
    fi
    echo "Using: $cmd ${args[@]}"
  fi
  
  if [ -f "$cmd" ] || [ -d "$cmd" ] ; then
      cmd_inside=$MNT/AppRun
      opts=loop,ro
      [ -d "$cmd" ] && opts=bind
      mount "$cmd" /tmp/$PREF/union/$MNT -o $opts
  else
      cmd_inside=$cmd
  fi

cat > /tmp/$PREF/union/run.sh <<EOF
#!/bin/sh
cat /etc/*release
echo ""
rm -rf /etc/pango
mkdir -p /etc/pango
pango-querymodules > '/etc/pango/pango.modules' 2>/dev/null # otherwise only squares instead of text
[ -f /si-chroot ] && ln -s /lib/ld-lsb.so.3 /lib/ld-linux.so.2
LD_LIBRARY_PATH=$MNT/usr/lib:$MNT/usr/lib32:$MNT/usr/lib64:$MNT/lib/:$LD_LIBRARY_PATH ldd $MNT/usr/bin/*  $MNT/usr/lib/* 2>/dev/null | grep "not found" | sort | uniq
export HOME="/root"
export LANG="en_EN.UTF-8"
# export QT_PLUGIN_PATH=./lib/qt5/plugins ###################### !!!
#dbus-launch $MNT/AppRun || 
export LIBGL_DEBUG=verbose
export QT_DEBUG_PLUGINS=1
dbus-uuidgen --ensure ; dbus-launch # Needed for CentOS 6.7 to launch apps that talk to dbus
if [ -f $MNT/usr/lib/qt5/plugins/platforms/libqxcb.so ] ; then
  export LD_LIBRARY_PATH=$MNT/usr/lib/:$LD_LIBRARY_PATH
  ldd $MNT/usr/lib/qt5/plugins/platforms/libqxcb.so | grep not
fi
find $MNT/usr/lib -type f -exec sh -c 'ldd {} | grep "not found"'  2>/dev/null \;
${cmd_inside} ${args[@]} && echo "+++++++++ SUCCESS $ISO $cmd +++++++++"
EOF
  chmod a+x /tmp/$PREF/union/run.sh
  echo ""
  chroot /tmp/$PREF/union/ /run.sh # $MNT/AppRun
  status=$?
  echo ""
  [ "$mode_i" == true ] || break
  read -p "Run another command [Y/n]? " answer
  [ "$answer" == "N" ] || [ "$answer" == "n" ] && break
done

exit $status
